* 第 1 部分：嘿，孩子，想试试 Janet 吗？。

作者说，他实际上并没有用 Janet 制作出一款完整的游戏。 他花了几周时间研究 Janet 和 Ra[1]ylib，学到了很多关于图形编程的知识，但在做出任何真正可玩的东西之前就决定停止了。 主要原因是因为这占用了他太多的时间，他有更重要的事情要做。

然后他了解到了 Autumn Lisp Game Jam：一个为期十天的 Lisp 语言游戏开发比赛。

他觉得这听起来很有趣，但不幸的是，他已经用完了今年的 Lisp 游戏预算。 不过，他确实学到了一些有趣的东西，并决定写下他所做的一些事情和学到的东西，因为他认为这可能对考虑使用 Janet 或 Raylib 参加比赛的人有用。

*为什么选择 Janet？*

作者说他没有自己喜欢的脚本语言。 Python 一[1]直是他的首选，但实际上他并不喜欢 Python。 他想要一种简单的类似 Lisp 的语言。 他听说过 Racket，但觉得它并不简单。 他对 Clojure 很感兴趣，但对于小[1]程序来说它太重了，而且上次使用 ClojureScript 的工具链让他感到痛苦。 他也听说过 Chicken Scheme，但 R5RS/R6RS/R7RS 的东西让他感到困惑和害怕。

然后，他看到[1]了一篇名为“为什么我将继续使用 Janet”的博客文章。 这篇文章激起了他的好奇心，他去了解了 Janet 是什么。

*Janet 是什么？*

Janet 是一种简单的动态类型解释型语言，具有[1]垃圾回收和类似 Clojure 的语法。 作者认为这正是他想要的。 他很高兴地看到 Janet 已经有一些有用的库，比如 SQLite 绑定、HTTP 服务器等。 这表明它不是一个完全的玩具语言。

其中一个绑定是 Raylib，他以前从未听说过。

*Raylib 是什么？*

Raylib 是一个简单的 OpenGL 包装库，具有非常简单的 API 和丰富的交互式浏览器内示例。 这[1]让作者非常兴奋，他想尝试一下 Raylib。 他决定同时尝试[1] Janet 和 Raylib。

*Jaylib 是什么？*

Jaylib 是 Janet [1]的 Raylib 绑定。 作者在尝试运行示例程序时遇到了问题。 他在 macOS 上使用 Nix 安装了 Janet，这导致了一些问题。 [1]他需要手动将 OpenGL 等框架添加到他的 `shell.nix` 文件中。

即使解决了这个问[1]题，Jaylib 仍然无法构建。 包含路径有问题，找不到 GLFW。 调试这个问题很困难，因为 Ja[1]net 的包管理器 `jpm` 似乎不支持 `--verbose` 输出。 最终，他发现 `project.janet` 文件中存在差异，并修复了它。

*jpm 的工作方式*

`jpm` 默认将所有依赖项安装到一个系统范围的目录中，并且不使用任何版本控制。 不过，[1]可以通过设置 `JANET_PATH` 环境变量来使用每个项目的目录。 依赖项必须是 Git 仓库的 URL。 这意味着如果你想对一个库进行更改，你必须将其推送到某个 Git 仓库才能[1]安装它。 作者找到了一个变通方法：使用 `jpm install` 而不是 `jpm deps`。

*构建 Jaylib*

作者最终成功构建了 Jaylib，并在此过程中学会了[1]如何对 Jaylib 进行更改。 示例代码也成功运行了。

*分发 Janet 程序*

作者发现分发用 Janet 编写的程序非常容易。 `j[1]pm build` 会生成一个静态链接的可执行文[1]件，其中包含所有依赖项。 这意味着其他人不需要安装 Janet 就可以运行他的程序。

*对 Janet 的看法*

作者非常喜欢 Janet 这门语言。 他喜欢它的设计选择，比如区分绑定和变量，以及显式[1]地重新分配变量。 他也喜欢它的字符串文字语法和拼接功能。

*游戏开发*

作者计划制作一款自上而下的程序化潜行射击游戏。 他首先实现了一个 2D 射线投射器来处理���线。 他发现了一篇关于 2D FOV 的很棒的文章，并以此为基础进行实现。 他还向 Jaylib 添加了一些[1]新功能，比如三角形扇形绘制和 HSV 转换。

文章最后展示了他第一天结束时的成果，并预告了接下来[1]的内容，包括使用有向距离场渲染软阴影、在 GPU 上进行实时光线追踪、添加动态光影、法线贴图、透明度、深度缓冲区等。 他[1]还提到，他可能会将这款自上而下的 2D 游戏变成一[1]款等距 3D 游戏。[1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1]


* 第二部分：评判Janet”。

为了在我的Janet小游戏项目中取得进展，我不得不编写一些测试。 因为尽管我[1]才刚刚开始，但已经遇到了一个bug。

（这个矩形的底部少了一块。这个矩形的底部不应该少一块。）

现在，我确信在编写光线投射器的过程中我写了很多bug，而且我也没有费心为它们编写任何测试——我只是修复它们，重新运行代码，然后手动验证bug已经消失了。

但这个bug[1]是一个非常“害羞”的bug。 很难手动复现它；很难触发导致它的确切条件。 因此，使用我通常的“猜测-检查”方法来修复它会非常烦人[1]——更容易的做法是触发一次条件，打印出状态，将其放入测试中，然后重新运行测试直到我找到修复方案。

但是，可悲的是，事情并没有那么简单。

因为我实际上不会写测试。

我只[1]会写“自我修改”的测试。

这是一种不幸的、无法治愈的状况。 既然我已经习惯了编写自动修改的测试，我就无法再回到编写充满布尔断言的测试了。 我已经尝过了仙馔，现在无法再回到喝葡萄酒了。

*什么是自我修改测试？*

这是我刚编造的一个术语。

我很抱歉。 据我所知，对于这种测试，没有一个标准的公认术语。

Mercurial称之为“统一测试”，这是我听说的第一个术语。 Jane Street称之为“期望测试”，所以在我脑海中它们[1]就是这个名字。 但大多数库似乎都重复使用“快照测试”这个术语。

但是“快照测试”这个术语太模糊了。[1] 自我修改测试是快照测试的一种，但并非所有快照测试都是自我修改测试。 所以在我找到一个更好的术语之前，或者在我克服自己开始像世界[1]上其他人一样称之为“快照测试”之前，我将使用这个愚蠢的术语。

不管怎样。

编写自我修改测试感觉就像在使用REPL（读取-求值-输出循环）。 一个所有编辑器集成都能正常工作、有你喜欢的键位绑定、没有奇怪的、半生不熟的readline需要你费力去应付的REPL。 你只需编写一个表达式，运行测试，然后在你的编辑器中就能看到结果。 一旦看起来正确，你就保存文件然后继续——如果它再次发生变化，测试就会失败。

更重要的是，阅读自我修改测试就像阅读RE[1]PL会话——我的大脑直观地比理解`assert`或`.expect.not.to.be.whatever`更容易[1]。 当测试失败时，你不会得到“断言失败：2应该是4”这样的信息，然后花一分钟[1]去弄清楚到底发生了什么，而是会看到一个差异对比，清楚地显示它应该是什么以及它实际上是什么[1]。 还有上下文等等。 这很棒。

我可以写一整篇文章来表达我有多么喜欢自我修改测试——而且我可能很快[1]就会这么做，只要我能想出一个更吸引人的术语——但现在我就只说这么多。

我写Janet写得很开心，但我需要写一些测试。

而且我无法再回到编写常规的基于断言的测试了。

所以我想我得写一个测试框架了。

*（疯狂编码蒙太奇）*

我写好了。 它完成了。 它能用。 如果你想用的话，你可以用。 我甚至还写了例子和文档。

它叫做Judge，看起来是这样的：


#+begin_src janet
(use judge)
(defn capitalize [str]
  (string (string/ascii-upper ([1]string/slice str [1]0 1))
          (string/slice str 1)))

(test "test capitalization"
  (ea[1]ch name ["eleanor" "chidi" "tahani" "jason"]
    (expect (capitalize name)
  [1]          "Eleanor"
            "Chidi"
            "Tahani"
            "Jason")))
#+end_src


但[1]这并不能完全体现它的优点。 所有的测试看起来都差不多。 要真正理解Judge，你需要观察它的运行过程。 因为它实际上是这样的：

（此处有一[1]个演示视频的描述）

我需要指出的是，尽管那是一个Emacs会话的录屏，但Judge没有任何Emacs特有[1]的东西。 这不是什么复杂的、连接到某种Emacs子进程并使用某种RPC机制来评估表达式和返回值的玩意儿，就像你在别处可能看到的那样。 它看起来很花哨，但你真正看到的只是一些命令：

  *  执行当前的[1]Janet文件（这会写出一个`test.janet.corrected`文件）
  *  显示`test.janet`和`test.janet.corrected`之间的差异
  *  将`test.janet.corrected`重命名为`test.janet`
  *  从磁盘重新加载`test.janet`，高亮显示任何差异

这些都是通用的操作，你可以[1]很容易地在任何编辑器中完成。 或者[1]不用编辑器也行！ 在我编写Emacs“集成”之前，我就是一直在命令行中这样做的。

不管怎样：这个工作流程很棒，使用起来非常愉快，但我并不幻想你会真的在我这个你几乎没听说过[1]的奇怪语言中使用我这个奇怪的测试库。 你来这里不是为了这个库；你是为了这个关于编写这个库的过于冗��、 rambling的故事。 我很乐意效劳。

*Judge是如何工作的*

Judge出奇地简单。 我是说代码。 Judge的核心——你导入来实际定义测试的API——只有大约100行代码。 测试运行器另外[1]还有300行左右，但那都是些直接的测试选择、参数解析和错误打印之类的东西。

但我花了一段时间才写完这些代码。 在这个过程中，我学到了很多关于Janet、关于宏以及关于lisp的知识。

所以让[1]我们把Judge分解成几个部分。 我们需要编写`test`宏来定义一个测试。 我们需要编写`expect`宏来定义一个特定的值。 我们需要一种重写Janet代码的方法，来生成`.corrected`文件。

让我们从最后一部[1]分开始，因为那是自我修改测试的关键——自我修改的部分。

所以：为了更新我们的测试，我们必须解析文件，找到我们想要更改的表达式，然后用新的表达式拼接进去重写文件。

但是我们怎么知道我们想要替换的表达式在哪里呢？ 当我们展开`expect`宏时，我们能以某种方式包含该宏在我们的测试文件中出现的位置吗？

[1]可以！ 而且非常容易。 看看这个：

```janet
$ cat example.janet

(defmacro print-location []
  (def filename (dyn :current-file))
  (def macro-invocation (dyn :macro-form))
  (def [line col] (tuple/sourcemap macro-invocation))
  ~(printf "Macro expanded at[1] %s:%d:%d" ,filename ,lin[1]e ,col))

(pr[1]int-location)
(print-location)

$ janet example.janet
Macro expanded at example.janet:7:1
Macro expanded at example.janet:8:1
```

在宏展开期间，Janet会设置一些我们可以读取的动态变量。 其中一个是`:macro-form`，正如你可能预期的那样，它就是实际被展开的表单。[1]

通常你不会真正关心这个，因为通常你只关心传递给你的宏的表单——宏的参数——但在我们的例子中，我们要重写整个`(expe[1]ct expression expected-value)`表单，而不仅仅是`expected-value`部分。

一旦我们有了这个，[1]我们调用`tuple/sourcemap`来获取该表单的行和列。

*关于元组*

`tuple/sourcemap`在几个方面都很奇怪。

首先，Janet没有“列表”。 它有[1]“元组”。 这是Janet对不可[1]变数组、不可变向量或任何你[1]想称呼它的东西的术语。

通常你会用方括号来写一个元组：`[1 2 3]`。 但[1]那只是一个引用表单的语法糖，对吧？


#+begin_example
repl> '(1 2 3)[1]
(1 2 3)
repl> [1 2 3]
(1 2 3)
#+end_example


除了……不完全[1]是。 因为看；还有更多：


#+begin_example
repl> '[1 2 3]
[1 2 3]
#+end_example


什么？

所以事实证明，元组有这个额外的信息：它们是“带括号的”元组还是“带圆括号的”元组。 你可以在运行时查询“元组类型”：


#+begin_example
repl> (tuple/type '(1 2 3))
:parens
repl> (tuple/type '[1 2 3])
:brackets
#+end_example


但请注意，任何在运行时创建的元组都是带圆括号的元组，即使它是用方括号定义的：


#+begin_example
repl> (tuple/type (tuple 1 2 3))
:parens
repl> (tuple/type [1 2 3])
:parens
#+end_example


这非常烦人，稍后会给我们带来麻烦。

如果我能改变Janet的一件事，那就是这个。 我会引入一个使用圆括号的一等[1]列表类型，将表单解析为列表，并规定元组总是用方括号表示。 但我不能。 所以……随[1]便吧。 我认为这是我在Janet中遇到的最恶心的东西，现在你也遇到了。 我希望这不足以让你对Janet望而却步，因为这门[1]语言的大部分内容都非常不错。

不管怎样，所有这些的重点是：我们的宏[1]可以访问它自己的表单，这是一个类型为`:parens`的元组。


#+begin_example
$ [1]cat example.janet

(defmacro even-simpler-macro []
  ~(pp (quote ,(dyn :macro-form))))

(even-simpler-macro)

[1]$ janet example.janet
(even-simpler-macro)
#+end_example


要提取该元组在我们的源文件中的位置，我们使用`tuple/sourcemap`。

*关于源映射*

好的，这部分也很恶心，但如果你能忍受`tuple/type`，那你就会没事的。

每个元组——无论是通过解析文件构造的元组、作为方括号[1]字面量构造的元组，还是在运行时动态构造的元组——每个元组都带有两个额外的值，无论它们是否有意义：“源映射行”和“源映射列”。

这些是[1]你的不可变元组中的可变值。 它们通常都设置为`-1`，但你可以调用`(tuple/setmap)`来改变它们：


#+begin_example
repl> (def runtime-tupl[1]e [1 2 3])
(1 2 3)
repl> (tuple/sourcemap runtime-tuple)
(-1 -1[1])
repl> (tuple/setmap runtime-tuple 10 20)
(1 2 3)
rep[1]l> (tuple/sourcemap runtime-tuple)
(10 20)
#+end_example


它们被设置的唯一情况是，如果它们是[1]由Janet解析器构造的元组——比如，引用的表单或宏参数——或者如果你自己设置了它们。

但是……为什么源映射存在于元组上？ 当然，Janet中的大多数表达式可能都是[1]元组。 但是如果我们想找到一个字符串字面量的位置呢？ 我们该怎[1]么做？

嗯，你看，问题是你有点做不到。

我的意思是，你有点可以。 如果你直接使用Janet的解析器API，你可以通过说“请把结果包装在一个元组里”来获取任意��的位置[1]。 这很奇怪；这很奇怪；感觉像是一个粗糙的hack，但这就是你做事的方式。

但是如果你在写一个宏——据我所知——你就没辙了。 你不能要求解析器将它传递给你的宏的表单包装在元组中。 这就是为什么我们要重写整个`(expect)`表达式，而不仅仅是它的一个参数：因为我们知道唯一可以被宏展开的表单是元组表单，所以我们知道`(dyn :macro-form)`将是一个带有源映射的[1]元组。

好的，所以这是谜题的第一块。 我们知道`(expect)`表单从哪里开始。

但这不足以重写文件。 从一个`[line column]`对到一个文件中的字节索引很容易，但是我们需要用我们的修正值替换多少个字节呢？

这就[1]更难弄清楚了。 我不确定正确的答案是什么，而[1]且我对我想出的解决方案不是很满意。

我的解决方案是使用Janet的解析器API，并从`expect`表单的[1]左括号开始解析文件：

#+begin_example

(ex[1]pect (+ 2 2) 4)
^
#+end_example


然后一次将解析器前进一个字节，直到解析器产生一个值，并计算你必须前进的字节数。 这很恶心，但它能用，而且我想不出更好的办法了。

**[1]我们做到了**

算是吧。

我们完成了第一部分；我们完成了自我修改的部分。 我们完成了困难的部分。 我们还需要完成其他部分，但你知道吗？ 我们可以把其他部分放在另一篇博文中。 录制那个小小的截屏花了令人沮丧的长时间，原因完全无趣，我现在累了，想出去走走[1]。


* 在 Janet 中制作游戏，第四部分：Janet 宏学


上一篇文章深入探讨了宏的秘闻，而这篇文章将继续这一趋势，讨论我在编写 Judge 时遇到的其他几个宏问题。

不过请注意：这篇文章中的所有内容都非常特定于 Janet，读完后你可能不会对宏、测试或编程有更深入的理解。如果你想回到可以实际应用于生活的内容，可以安全地跳到下一篇文章。

还在这里？好的，太好了。

** 再谈元组

让我们从一个简单的开始。还记得 Janet 同时有方括号元组和圆括号元组吗？快速回顾一下：


#+begin_example
repl> '(1 2 3)
(1 2 3)
repl> [1 2 3]
(1 2 3)
repl> '[1 2 3]
[1 2 3]
#+end_example


这意味着当你编写涉及元组的期望时，它们看起来……很傻：


#+begin_example
(expect [1 2 3] (1 2 3))
#+end_example


是的！就像那样。我看着也不对劲, 我希望它是这样的：


#+begin_src janet
(expect [1 2 3] [1 2 3])
#+end_src


所以……我就这么做了。当我打印元组时，我实际上将元组打印为方括号元组，无论其类型如何。

我这样做之后意识到，这会使得为宏扩展编写测试变得困难，或者在其他你确实希望看到圆括号元组的情况下也是如此。

我想你或许可以通过这样一种方式来解决这个问题：如果这是一个附加了源映射的元组，那么保留它的方括号形式。如果它是一个没有附加源映射的元组，则用方括号打印它。

我想这样可能会更有效？但我实际上没有尝试过。因为……嗯，因为接下来的事情。

** 限制 (expect)

在编写 Judge 时，我想要一个限制：我希望只能在 `(test)` 的主体中使用 `(expect)` 宏。你不能随心所欲地在代码中散布 `(expect)`，并期望 Judge 能为你神奇地更新所有这些。它没那么智能。

好，一种方法是让 `(test)` 宏扩展为定义 `(expect)` 宏的东西：


#+begin_src janet
(defmacro test [name & forms]
  ~(do
     (defmacro expect [...])
     ...
     ,;forms))
#+end_src


但我认为这在人体工程学上有点奇怪。我期望 `expect` 是在 `judge` 模块中定义的宏。我期望如果我运行 `(import judge)`，那么我将把 `judge/test` 和 `judge/expect` 宏引入作用域。这些应该像常规宏一样出现，即使你不能在任何地方使用它们。

所以这种方法不是很好。

另一种方法是定义一些“私有符号”，并在测试主体的词法作用域中设置它，并尝试在 `expect` 宏的扩展中查找它。


#+begin_src janet
(def $unique-test-proof (gensym))

(defmacro test [name & forms]
  ~(do
     (def ,$unique-test-proof "yeah you did it")
     ,;forms))

(defmacro expect [...]
  ~(do
     (unless (in (fiber/getenv (fiber/current)) ,$unique-test-proof)
       (error "oh no you aren't in a test right now"))
     ...))
#+end_src


但问题是……我直到刚才才想到这个方法。

我不认为这有什么问题；我没这么写只是因为我不知道如何在运行时检查当前的词法环境。我的思维仍然停留在优化、提前编译的编译器上，而不是动态解释器，在这种解释器中，这种反射是微不足道的。

无论如何，这似乎比我编写 Judge 时想出的解决方案要好得多。但我们仍然会讨论那个更奇怪的方法，因为它会引导我们进入一个关于宏的更有趣的切线：

我所做的是让 `(test)` 宏设置一个动态变量，表示“是的，我现在在测试中，一切正常”。

起初这听起来很疯狂，因为宏扩展是自外向内工作的，对吧？Janet 会扩展外部宏——`(test)` 宏——这将返回一些形式。然后它会扩展这些返回形式中的任何宏，依此类推，直到没有东西可以扩展为止。

所以当你在 `(test)` 中设置一个动态变量时，没有办法在扩展发生后取消设置它。你会设置它，返回形式，然后……好吧，现在那个动态变量被永久设置了；希望这就是你想要的。

为了解决这个问题，我让 `(test)` 在一个 `(with-dyns)` 形式内手动调用其参数的 `(macex)`。有点像这样：


#+begin_src janet
(defmacro test [name & forms]
  ...
  (def expanded-forms
    (with-dyns [:i-am-in-a-test true]
      (macex forms)))
  ...)
#+end_src


我对此感到很奇怪，但我并没有真正深入思考。但回过头来看，我对此感到非常奇怪，因为我期望 `macex` 实际上在我的宏定义的词法环境中进行，而不是在我的形式被编写的环境中。引用的形式不会随身携带它们的词法环境。对吧？

这是一个我所说的最小例子：


#+begin_example
$ cat test.janet

(defmacro test [& forms]
  (pp forms)
  (pp (macex forms))
  ~(do ,;(macex forms)))

(defmacro something []
  ~(print "hello"))

(test
  (something))

$ janet test.janet
((something))
((print "hello"))
hello
#+end_example


所以这工作得很好，对吧？因为我们在宏主体的环境中运行 `macex`，并且在调用 `macex` 时，其父环境包含 `something` 绑定。或者，用人类的话说：`something` 在我们调用 `macex` 时在作用域内，所以它做了我们期望的事情。

但如果不是呢？如果我们在一个单独的文件中声明 `something`，并尝试从那里调用它呢？


#+begin_example
$ cat test.janet

(defmacro- something []
  ~(print "test.janet"))

(defmacro test [& forms]
  (something)
  (pp forms)
  (pp (macex forms))
  ~(do ,;(macex forms)))

$ cat example.janet

(use ./test)

(defmacro- something []
  ~(print "example.janet"))

(test
  (something))
#+end_example


在我向你展示输出之前……你期望 `janet example.janet` 会打印什么？这是一个值得思考的有趣问题。我对结果感到有些惊讶。

准备好了吗？

剧透如下：


#+begin_example
$ janet example.janet
test.janet
((something))
((print "example.janet"))
example.janet
#+end_example


好的。所以不知何故，一切都完全按照我想要的方式工作，而不是我期望的方式。

我不明白这一点；我不明白为什么我的 `macex` 调用不知何故扩展了在不同作用域中定义的这些宏。

看起来我们还在两个不同的地方以两种不同的方式扩展了 `(something)` 宏，但请记住，`(print "test.janet")` 是因为该宏扩展发���在我们定义 `test.janet` 中的 `test` 宏时，而不是在我们扩展 `example.janet` 中的 `test` 宏时。

Janet 文档没有讨论宏扩展究竟是如何工作的，所以我不得不去查看源代码来理解这一点：


#+begin_src c
static int macroexpand1(
    JanetCompiler *c,
    Janet x,
    Janet *out,
    const JanetSpecial **spec) {
  /* ...lots of stuff omitted... */
  JanetBindingType btype = janet_resolve(c->env, name, &macroval);
  if (btype != JANET_BINDING_MACRO || !janet_checktype(macroval, JANET_FUNCTION))
    return 0;
#+end_src


所以如果我没读错的话，我认为这里发生的是 `macex` 总是在编译器当前正在编译的环境中查找符号。`macex` 调用的环境根本不重要；重要的是编译器正忙于编译 `(test (something))` 形式，并且在该环境中，`something` 扩展为 `'(print "example.janet")`。

所以宏定义在某种程度上，实际上是动态作用域的——但由于宏扩展通常在你的文件中以简单的自上而下的顺序进行，你实际上不会注意到这一点。

但这很奇怪，对吧？因为那么如果我们在运行时调用 `macex` 会发生什么？


#+begin_example
cat runtime.janet

(defmacro- something []
  ~(print "hi"))

(pp (macex '(something)))

(defn main [&]
  (pp (macex '(something))))

$ janet runtime.janet
(print "hi")
(something)
#+end_example


嗯，这至少与我的解读是一致的。编译器在运行时没有“当前作用域”，所以它无法进行宏查找。所以你不能在运行时扩展宏。即使你在运行时定义宏……？

#+begin_example
cat runtime.janet

(defn main [&]
  (defmacro- something []
    ~(print "runtime macro party whoooo"))
  (pp (macex '(something))))

$ janet runtime.janet
(something)
#+end_example


不行。不是一回事。好吧，当然——在运行时定义宏确实没什么意义。我对此没意见。

但在运行时扩展宏是有意义的。这可能听起来很疯狂，但我实际上有一个非常合理的用例：我希望能够为宏扩展编写测试：


#+begin_example
(defmacro something []
  '(print "hello"))

(test "something is a trivial macro"
  (expect (macex '(something)) (print "hello")))
#+end_example


那不是很好吗？在编写 Judge 时，我经常需要运行 `(pp (macex '(test ...)))`。这对于帮助我理解准引用非常有帮助。但是 Judge 的交互式工作流程非常好，我希望能够将这些扩展直接嵌入到我的源文件中，并看到它们何时发生变化。

但为了做到这一点，我必须在编译时执行扩展：


#+begin_example
(defmacro something []
  '(print "hello"))

(def expansion (macex '(something)))

(test "something is a trivial macro"
  (expect expansion (print "hello")))
#+end_example


这有点麻烦，但无所谓。这不是一个坏的解决方法。

无论如何。这种行为有点令人惊讶，对吧？

#+begin_example

$ cat test.janet

(defmacro- something []
  ~(print "lexical scope"))

(defmacro test [& forms]
  (pp (macex '(something)))
  ~(do (print ":(")))

$ cat example.janet

(use ./test)

(defmacro- something []
  ~(print "dynamic scope"))

(test
  (something))

$ janet example.janet
(print "dynamic scope")
:(
#+end_example


** 天哪，谁在乎呢

是的，这是 Janet 的一些有趣的琐事，但它们都真正影响我们编写小游戏的能力。

这种行为对我来说有点像一个 bug，但也许有什么原则性的原因导致它必须这样工作。我不知道：我从未实现过编译器。而且由于我现在并没有迫切需要编写复杂的宏测试，我不会再深入研究这个问题。

所以让我们回到游戏。


** *用Janet制作游戏，第五部分：对Judge进行测试*

好了，我们刚刚花了两篇文章讨论了关于宏的一些奇特的知识。我们已经完全忘记了当初为什么要写一个测试框架，所以让我们回顾一下我们试图修复的那个bug：

这并不是一个特别困难、复杂或可怕的bug。你甚至只要看看那张图片就能发现问题所在：光线没有被正确排序。右下角那条绿色的光线顺序错了，这搞乱了三角形扇面（triangle fan）的渲染。

所以你大概能猜到我接下来要做什么了——你知道我最终会为“围绕原点对点进行排序”的函数编写一个测试用例。就像这样：


#+begin_src janet
(test "triangle fan points are sorted in the right order"
  (def points [[14.2 103.2] [123.442 132.44] ...])
  (expect (sort-points points) [[48.1232 302.1] [48.132 444.23] ...]))
#+end_src


这是一种更好的展示问题的方式，因为它是一个单元测试。编写单元测试非常重要，因为否则我们就没有良好的测试覆盖率——而如果没有良好的测试覆盖率，我们也就没有遵循测试驱动开发（TDD）的原则。所以，即使这个测试读起来有点困难，即使通过玩游戏来验证修复是否正确比看这个测试更容易，但按照最佳实践，我们还是应该这样做。

哈哈，不，我显然是在开玩笑。

那个测试简直是垃圾。我们不会写那样的测试。我们要写的是这个：

*这是什么魔法？*

好吧，我知道我之前说过Judge没有任何Emacs特有的东西，你可以在任何编辑器中使用它，一切都会正常工作。那完全是真的。我没有骗你。

你现在看到的其实是一个这样的文件：


#+begin_src janet
(render-test "sort points"
  (draw-frame-as screenshot 256 128
    (def ray-results (me/cast-rays [0 0] walls))
    (def points (random-points 100 64))
    (draw-points [-64 0] points)
    (draw-points [+64 0] (sorted points clockwise-comparator)))
  (expect screenshot screenshots/c46a045af4a02a4ec19cb78034216be4.png))
#+end_src


但是通过在上面撒上一点Emacs的“仙尘”，我们就可以让Emacs显示出那张图片的内联预览。

这虽然不是必需的，但真的很棒！我们不必牺牲自修改测试的任何便利性；我们不必退化到编写普通的、无聊的、带外（out-of-band）的快照测试，仅仅因为我们觉得用图片来表达这个测试是最好的方式。

所以我们所要做的就是将当前的图形上下文捕获为一个纹理，将该纹理保存到一个临时文件中，对其内容进行哈希计算，然后将其移动到一个小小的`screenshots`目录中，并使用一个与其内容匹配的名称。没什么神奇的，也没什么疯狂的。

但与此同时……

这还是有点神奇的，不是吗？

*你又要开始诗意地……*

有很多方法可以让你相信你的代码是有效的。你可以运行它。你可以在REPL中摆弄它。你可以添加调试打印语句。你可以用任何你喜欢的方式“手动验证”它是否有效。

但是当你把你的证据——以测试的形式——写下来时，你就获得了一种很酷的超能力。你获得了分享证据的能力。在不同的时间和空间重新创建你的论证。这样，如果你有任何疑问——那还管用吗？我最新的改动把它弄坏了吗？——你就可以重新走一遍之前的步骤，再次说服自己。

但要让这一切奏效，你的测试必须具有说服力。

我感觉关于测试的讨论总是关注于防止“回归”（regressions）。试图防止未来的bug。这显然非常有价值——但测试可以做的远不止这些。测试可以是文档；测试可以是你代码在某些方面表现——或不表现——的论据。

我认为上面的图片就是一个非常好的论据。一眼就能看出bug所在；它让我们一眼就相信我们有问题。一旦我们调整了代码，我们就能轻易地观察到我们的改动所带来的效果。

这不是一个好的回归测试。它只测试了这一个例子，用一个精心选择的随机种子来触发这个bug。一旦我们改变了代码，我们不知道我们是否真的修复了它，还是它只是躲起来了。

如果我的生计在某种程度上依赖于这个函数的正确性，我会选择编写一个属性测试，将我的实现与基于`atan`的简单比较器进行比较。但我写这个测试不是为了这个。我写这个测试是为了让我更容易修复这个bug。我写这个测试是为了让我能更容易地观察我代码的行为。

*我好像刚才睡着了一分钟*

好吧，关于测试的本质我就说这么多。你懂的。谢谢你的包容。

所以我写Judge的真正原因是我想要写带图片的测试。我认为这会使测试非常易读；我认为我能说服自己我做的所有奇怪的向量运算都确实有效；我认为这将是一个有用的工具，能帮助我更好地理解我的代码。

而且它确实是！它非常有用，真的——但我不想剧透。我只想说：我们会在未来的博客文章中回到这个技术。

所以对我来说，让Judge能够支持这个工作流程非常重要。那么这需要什么呢？

*不多！*

实际上，初步来看，什么都不需要。一旦我让`(test)`和`(expect)`宏工作起来，我就能写出完全像这样的测试。只有一个小问题：它们很慢。

我说的是三位数的毫秒级慢。慢得令人无法接受，慢得难以置信。人眼都能察觉到的慢。

问题在于我在每个测试中都创建了OpenGL图形上下文。在每个测试中都初始化了Raylib。所以每个测试都要花费大约150毫秒来设置和拆卸这些东西。那会很糟糕，我也不会费心去写任何带图片的测试，我也会很难过。

所以我不得不在Judge中做一些工作来更轻松地支持这个工作流程。

这就引出了我们的最后一个宏。你已经见过了`test`和`expect`——现在我们来谈谈`deftest`。

`deftest`让你定义一种新的“类型”的测试。这里有一个例子：


#+begin_src janet
(deftest render-test
  :setup (fn []
           (jaylib/set-trace-log-level :warning)
           (jaylib/set-config-flags :window-hidden)
           (jaylib/init-window 1 1 "render-test"))
  :reset (fn [_] nil)
  :teardown (fn [_]
              (jaylib/close-window)))
#+end_src


`deftest`是一个定义另一个宏的宏。这听起来可能像是高级的宏魔法，但实际上并没有那么糟糕。是的，有嵌套的准引用（quasiquotes），但一旦你写过一次，它们其实并不难理解。这是一个很好的、拓展思维的练习。

老实说，关于实现我没什么有趣的可说的。在我们经历了宏的所有其他事情之后，这非常直接。

那么：它是如何工作的？

嗯，你其实已经见过了，虽然你可能没有注意到。但再看看这个测试：


#+begin_src janet
(render-test "sort points"
  (draw-frame-as screenshot 256 128
    (def ray-results (me/cast-rays [0 0] walls))
    (def points (random-points 100 64))
    (draw-points [-64 0] points)
    (draw-points [+64 0] (sorted points clockwise-comparator)))
  (expect screenshot screenshots/c46a045af4a02a4ec19cb78034216be4.png))
#+end_src


`render-test`基本上和`test`一样，只不过你知道所有的`render-test`都会在OpenGL上下文已经初始化的情况下被调用，所以你只需要支付一次启动的开销。

它的行为完全符合你的预期：测试运行器在第一次遇到`render-test`时会调用你的`setup`函数。然后在所有`render-test`都完成后运行一些`teardown`代码。

你也可以选择在每个单独的测试之前“重置”你的上下文——虽然在这种情况下没有必要。但如果你想更进一步，比如，在每个测试之间共享同一个纹理，那么你就可以在`reset`中清空它。但我不需要这样做。

因为测试本身很快。即使它们在分配纹理、绘制线条、编码PNG、哈希文件——所有这些都几乎是瞬间完成的。至少是亚毫秒级的；我没有费心去用更高的分辨率来测量。快到我可以随心所欲地写任意多的测试，而不用担心在很长一段时间内需要优化它们。感谢电脑。

所以这就是`deftest`。我试图让它足够通用，以便在其他情况下可能有用，但我脑海中唯一的真实用例就是这个特定的Raylib启动问题。

那么让我们再多谈谈这个。

**快照测试**

这种“快照测试”有一个恼人的具体问题：图片很大。

PNG文件比源代码大得多。如果我们每次克隆仓库或做其他事情时都必须下载几兆字节的图片，那会非常烦人。`pngcrush`确实有很大帮助，但保持文件大小的最好方法是渲染低分辨率的图片。

但我们不想做出一个权衡：低分辨率的图片也更难看。它们太小了！我不想眯着眼睛看我的测试。所以虽然我愿意渲染低分辨率的图片���但我希望在实际查看它们时能把它们放大。

没问题，对吧？Emacs可以做到。

哦天哪，哦天哪，哦不。那太糟糕了。那绝对不行。

所以那是一张20x20的图片，只有97字节——比这个句子的UTF-8编码还要小。但当我把它放大以便我能真正看到它时，它变得非常模糊，因为当Emacs缩放图片时，它使用的是双线性图像滤波器。对照片来说很好；对像素艺术来说很糟糕。

可悲的是，Emacs——尽管它大谈特谈定制化，尽管它大肆宣扬用户配置它的能力——却没有提供任何改变这种行为的方法。没有办法设置不同的插值函数。

所以我们必须选择：我们是渲染高分辨率的图片并让我们的仓库膨胀，慢慢积累一些难以量化的债务，我们未来的自己总有一天要处理？还是我们接受模糊，眯着眼睛看我们的测试，然后继续我们的生活？

不；我们当然要给Emacs打补丁来解决这个问题。但我们可以把这个留到下一篇文章。


Sources:
[1] Making a Game in Janet, Part 5: Putting Judge to the test - Ian Henry (https://ianthehenry.com/posts/janet-game/putting-judge-to-the-test/)\n---\n
好的，这是该网页内容的中文翻译：

** 在 Janet 中制作游戏，第 6 部分：如何为 Emacs 打补丁 - Ian Henry

这篇文章是作者正在进行的“在 Janet 中制作游戏”系列的一部分，相当于一个业余项目日记。

*核心问题*
作者在为他的游[1]戏编写带图片的测试时遇到了一个问题：当他放大图片时，图片会变得非常模糊。 他认为这是一个很容易解决的问题，只需要将 Emacs 的图像缩放算法从默认的“双线性重采样”改为“最近邻重采样”即可。这应该只是一行代码的改动。

*挑战：编译 Emacs*
然而，这一行代码的改动代价高昂：他必须先学会如何编译 Emacs。 作者描述了编译 Emacs 的传统困难：需要弄清楚一大堆依赖项（如 GCC 工具链、HarfBuzz、各种图片格式的库等），并且安装说明长篇大论。 他开玩笑说，如果是一年前的他，可能会花上六个小时去折腾编译环境，最后可能因为一[1]个段错误（segfaults）而放弃。

*秘密武器：Nix*
但现在作者有了一个秘密武器：Nix。 Nix 是一个包管理器，作者花了一些时间学习它，虽然过程很复杂，但他认为很���得。 有了 Nix，他不再需要自己研究如何编译 Emacs，因为 Nix 的表达式已经精确地描述了构建一个软件所需的所有依赖和步骤。

*Nix 与其他包管理器的对比（如 Homebrew）*
作者将 Nix 与 Hom[1]ebrew 等其他包管理器进行了比较。 理论上，也可以用 Homebrew 来给软件打补丁，但人们通常把它当作一个下载预编译二进制文件的工具。 而 Nix 的核心就是“构建软件”，它让用户能以一种跨平台、机器可读的方式来指定系统依[1]赖。 作者认为，正是这种对包管理系统更深入的理解，才赋予了他轻松修改 Emacs 的“超能力”。

*打补丁的过程与一个“愚蠢”的错误*
补丁本身很简单，就是在 `macterm.c` 文件中添加一行代码，以启用无插值的图像绘制。 但在应用补丁时，他遇到了麻烦。他使用的 Emacs 是一个针对 macOS 的特定分支（emacsMacport），其 Ni[1]x 构建脚本没有使用标准的补丁机制。

作者修改了他的 Nix 配置文件以使用内置的补丁功能，但补丁一直应用失败。 在排查了很久之后，他才发现问题所在：当他把补丁代码粘贴到配置文件中时，他的编辑器自动将代码中的制表符（tabs）转换成了空格。而他要修改的 Emacs 源代码恰好混用了制表符和空格进行缩进，这个微小[1]的差异导致了补丁失败。

*更深远的意义*
作者借此阐述了一个更宏大的观点：我们每天都在使用开源软件（如 git, tmux, fzf），理论[1]上当软件不符合我们的期望时，我们可以自己修复它。 但实际上，为每个项目配置独特的构建环境和维护自己分支的成本非常高，导致大多数人望而却步。

而 Nix 极大地降低了这一门槛。通过 `nix-shell` 命令，他可以为任何软[1]件包快速创建一个可用的构建环境，并且可以让 Nix 自动将他的补丁应用到软件的最新版本上，无需手动维护分支。

*回到游戏开发*
最后，作者确认补丁成功了，测试框架中的图片在放大后不再模糊。 在完成了这个关于如何给 Emacs 打补丁的“长篇大论”后，他表示现在终于可以回到真正的游戏开发工作上来了。
